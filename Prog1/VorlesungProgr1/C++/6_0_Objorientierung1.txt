=============================================Objektorientierung1=======================================290-324
---------Objektorientierung: Paradigma, leisten einer Abbildung: 
	vom Problemraum(Dinge d.realen Welt) in Lösungsraum(Einheiten d.laufenden Programms)
	(nach ISO: Technik oder Programmiersprache betreffend, die Objekte, Klassen, Vererbung unterstützt)


---------Objekt (Abbildung d.Dinge d.realen Welt auf Objekte)
	OBJEKT hat ATTRIBUTE/Daten als Eigenschaften: Verhalten d.Eigenschaften durch METHODEN modelliert

z.B Objekt aus echtem Leben wird modelliert durch...Auto->Klasse Auto...
	|------Auto-----|						|-RadHintLinks--|	|-RadHintRechts-| 	: Objektname}
	|Geschwindigkeit|-enthält(Aggregation)->|Durchmesser	|	|Durchmesser	| 	} Attribute	} Objekt
	|Beschleunigung |						|...			|	|Luftdruck		| 	} mit 		}
	|...			|<----Instanz von---------------------------|...			| 	} Werten 	}

Objekt hat Zustand(durch Menge seiner aktuellen Attributwerte beschrieben)
Objekt hat Verhalten(durch Menge seiner Operationen/Methoden/Funktionen beschrieben)
-->Attribute definieren aktuellen Zustand / Methoden definieren Verhalten


--------Klasse: wenn Objekte dieselben Attribute u. Eigenschaften haben: gruppierung zu Klassen
Objekt ist Instanz einer Klasse (Exemplar)
Mehrode spezifiziert gemeinsame Attribute u. Methoden (^=Bauplan/Schablone)

Möglichkeiten einer Klasse: Klasse ist Datentyp(Erweiterung von "struct")
	-unterbringen von Funktionen (Methoden, member functions)
	-Ableitung von bestehenden Klasse (Vererbung)
	-Vergeben von Zugriffsrechten (-private: kein Zugriff von außen, -public:Zugriff von außen mögl.)

Definition: 
class Rad{
	float umdrehungszahl;	---
	float durchmesser;		---Addribute
	...						---
	float berechne_geschwindigkeit(){return durchmesser * 3.14 * umdrehungszahl; }	---Methode
};	---------Semikolon notwendig!!


--------Zugriffsrechte: standard(ohne Zuweisung), alle Elemente: private	(struct: public)
class Rad{
	private: 
		float solldruck;
		...
	public: 
		float durchmesser
}


--------Erzeugung von Objekten:
Klasse: wie Datentyp verwendbar(erzeugung v."Variablen": Objekte der Klasse, Zugriff mit Punkt-Operator)
Erzeugen des Objekts: Rad rvl;
Zugriff auf Objekt: rvl.berechne_geschwindigkeit()


-------Kapselung d.Attribute: DIREKTER ZUGRIFF auf Attribute sollte NICHT MÖGLICH sein
-->Zugriff über Setter-/Getter-Methoden
void set_umdrehung(float u){umdrehung = u;}
float get_umdrehung(void){return umdrehung;}

------Dynamische Objekte: entsprechen dynamischen Variablen in C:
Anlegen bei Bedarf mit new-Operator zur Laufzeit auf d.Heap (gibt Zeiger auf Objekt zurück)
Gültigkeit/Lebensdauer NICHT durch statische Programmstruktur bestimmt, Objekte: nicht automatisch gelöscht
Löschen mit delete-Operator(von Heap entfernt) -> manuell:Zeigervariable=NULL, sonst wird Speicher erschöpft
Objekte werden automatisch nach Programmende gelöscht

-----Trennung Deklaration/Definition:
Empfehlung: Jede Klasse in eigene Header-/Quellcode-Datei mit Namen der Klasse (klassenname.c/.cpp)
Gründe für die Aufteilung auf mehrere Dateien:
	-bessere Übersicht/Auffinden von Klassen/Methoden, 
	-schnelleres Kompillieren: nur übersetzt, wenn selbst oder durch inkl.Header-Dateien geändert
	-bei Team: vermeidbar, dass Zwei Programmierer an selber Datei arbeiten
Methoden: außerhalb d.Klassendeklaration (in seperaten Quellcode-Datei) definieren
Trennen von Klassen-Definition u.-Deklaration(Implementierung)
Klassen-Deklaration immer in Header-Datei(in jeder Datei, i.d.Klasse verwendet inkludieren)
Bezug zu Klasse mit Scope-Resolution-Operator "::"
Eigentliche Definiton d.Klasse getrennt übersetzt, mit Linker dazu gebunden

----Konstruktor: Versetzen eines Objekts in Anfangszustand: 
Bereitstellung d.Speicherplatzes für Attribute, Initialisierung von Attributen mit sinnvollen Anfangswerten
	-Aufrufe: automatisch in Programm eingefügt(wenn Objekt erzeugt, Klasse verfügt über Konstruktor)
	-tragen denselben Namen wie Klasse, haben keine Rückgabewerte

-Standardkonstruktor/Defaultkonstruktor: 
	Verwendung bei jeder Erzeugung eines Objekts d.Klasse wenn kein Konstruktor explizit definiert ist
	hat keine Parameter, reserviert Speicher, macht KEINE Initialisierung
	i.d.R durch selbst geschriebenen Konstruktor ersetzt
-Allgemeiner Konstruktor(vom Programmierer geschr.): 
	beliebige Argumente, überladen ist mögl.: mehrere Konstruktoren mit verschiedenen Argumentlisten
-Kopierkonstruktor(copy const.): 
	Initialisierung eines Objekts d.Klasse mit anderen derselben Klasse
-Typumwandlungskonstruktor: 
	nur ein Argument: Umwandlung anderer Datentyp in Klasse(als Typ gesehen)
	
	


---312